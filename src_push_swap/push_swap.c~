#include "../push_swap.h"
#include <stdio.h>

typedef struct s_solve
{
	int left;
	int right;
	int pivot;
	int swap;
}				t_solve;

int	*get_numbers(char **argv)
{
	int i;
	int *ret;

	i = 1;
	while (argv[i])
		i++;
	if (!(ret = malloc(sizeof(int) * i)))
		return (0);
	i = 1;
	while (argv[i])
	{
		ret[i - 1] = ft_atoi(argv[i]);
		i++;
	}
	return (ret);
}

void	print_stack2(int *stack, int len)
{
	int i;

	i = 0;
	while (i < len)
	{
		printf("%d ", stack[i]);
		i++;
	}
}

void	swap(int *a, int *b)
{
	int swap;

	swap = *a;
	*a = *b;
	*b = swap;
}

void	print_loop(char *message, int n)
{
	int i;

	i = 0;
	if (n <= 0)
		return ;
	while (i < n)
	{
		printf("%s", message);
		i++;
	}
}

void	quicksort(int *stack, int start, int end)
{
	int pivot;
	int l_most;
	int r_most;
	
	if (!(start < end))
		return ;
	pivot = end;
	l_most = start;
	r_most = pivot;
	while (l_most < r_most)
	{
		while (stack[l_most] <= stack[pivot] && l_most <= end)
			l_most++;
		while (stack[r_most] > stack[pivot] && r_most >= start)
			r_most--;
		if (l_most < r_most)
			swap(&stack[l_most], &stack[r_most]);
	}
	swap(&stack[pivot], &stack[r_most]);
	quicksort(stack, start, r_most - 1);
	quicksort(stack, r_most + 1, end);
}

void	init_solve(t_solve *solve, int len)
{	
	solve->pivot = len - 1;
	solve->left = 0;
	solve->right = len - 2;
}

t_stack		*get_last(t_stack *stack)
{
	t_stack *last;

	last = stack;
	while (last->n)
		last = last->n;
	return (last);
}

int		get_mid(int *stacka, int *index)
{
	int i;

	i = index[0];
	while (i < (index[1] - index[0]) / 2)
		i++;
	return (i);
}

int		*stack_to_int(t_stack *stack)
{
	int *new;
	int i;
	t_stack *ptr;

	i = 0;
	ptr = stack;
	if (!(new = malloc(sizeof(int) * stack_len(stack))))
		return (0);
	while (ptr)
	{
		new[i] = ptr->elem;
		i++;
		ptr = ptr->n;
	}
	return (new);
}

int		get_mid_index(int *stacka, int len)
{
	int i;
	
	i = 0;
	while (len - i != (len / 2))
		i++;
	return (i);
}


int		is_sorted_rev(t_stack *stack)
{
	t_stack		*ptr;
	int			i;

	i = -1;
	ptr = stack;
	while (ptr)
	{
		if (i != -1 && ptr->elem > i)
			return (0);
		i = ptr->elem;
		ptr = ptr->n;
	}
	return (1);
}

int		is_sorted(t_stack *stack)
{
	t_stack		*ptr;
	int			i;

	i = -1;
	ptr = stack;
	while (ptr)
	{
		if (i != -1 && ptr->elem < i)
			return (0);
		i = ptr->elem;
		ptr = ptr->n;
	}
	return (1);
}

int		check_last(t_main *main)
{
	t_stack *ptr;

	ptr = main->stacka;
	if (stack_len(ptr) == 2 &&
	ptr->elem > ptr->n->elem)
		s(&main->stacka);
	return (0);
}
int		put_to_b(t_main *main, int *stacka)
{
	int i;
	int mid;
	int end;
	t_stack *last;
	
	i = 0;
	end = stack_len(main->stacka);
	if (end == 2)
		return (check_last(main));
	mid = stack_len(main->stacka) / 2;
	push(&main->chunks, mid);
	while (i != mid)
	{
			if (main->stacka->elem < stacka[mid])
			{
				p(&main->stacka, &main->stackb);
				i++;
			}
			else
			{
				last = get_last(main->stacka);
				if (main->stacka->n->elem >= stacka[mid] &&
				last->elem < stacka[mid])
					rev_r(&main->stacka);
				else
					r(&main->stacka);
			}
	}
	if (end == 3)
		return (check_last(main));
	return (1);
}

int		*stack_to_int2(t_stack **stack, int end)
{
	t_stack	*ptr;
	t_stack *ptr2;
	int		i;
	int		*ret;
	
	i = -1;
	ptr = *stack;
	printf("//%d", end);
	if (end == 1)
		return (stack_to_int(*stack));
	while (++i <= end)
		ptr = ptr->n;
	ptr2 = ptr->n;
	ptr->n = NULL;
	ret = stack_to_int(*stack);
	ptr->n = ptr2;
	return (ret);
}

int		move_chunk(t_main *main)
{
	t_stack *ptr;

	ptr = main->chunks->n;
	free(main->chunks);
	main->chunks = ptr;
	return (1);
}

int		get_to_put(int *stacka, int len, int mid)
{
	int ret;
	int i;

	i = 0;
	ret = 0;
	while (i < len)
	{
		printf("[%d]", stacka[i]);
		if (i > mid)
			ret++;
		i++;
	}
	return (ret);
}

int		case_one(t_main *main)
{
	p(&main->stackb, &main->stacka);
	move_chunk(main);
	return (1);
}

int		check_cases(t_main *main)
{
	if (main->chunks->elem == 1)
		return (case_one(main));
}

int		put_to_a(t_main *main, int *stacka)
{
	int mid;
	int max;
	
	if (check_cases(main))
		return (1);
	mid = main->chunks->elem / 2;
	max = get_to_put(stacka, main->chunks->elem, mid);
}

void	init_stack_sort(t_main *main, int *stacka, int len)
{
	int i;

	i = len - 1;
	while (i >= 0)
	{
		push(&main->stacka, stacka[i]);
		i--;
	}
	quicksort(stacka, 0, len - 1);
	while (!is_sorted(main->stacka) && put_to_b(main, stacka))
	{
		free(stacka);
		stacka = stack_to_int2(&main->stackb, main->chunks->elem);
		quicksort(stacka, 0, stack_len(main->stacka) - 1);
	}
	i = 0;

	stacka = stack_to_int2(&main->stackb, main->chunks->elem);
	print_stack(main->stacka);
	//print_stack(main->stackb);
}

int	main(int argc, char **argv)
{
	t_main	main;
	int		*stacka;
	int		*index;
	int		len;

	len = argc - 1;
	if (!check_format(&stacka, &len, argv))
		return (exit_push_swap("Error\n"));
	if (!(index = malloc(sizeof(int) * 2)))
		return (0);
	main.stacka = NULL;
	main.stackb = NULL;
	init_stack_sort(&main, stacka, len);
}
